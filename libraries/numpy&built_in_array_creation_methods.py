# -*- coding: utf-8 -*-
"""numpy&Built-in Array Creation Methods.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wDvq0sUvTw-A1fLBVGHteq-s_c3d5OTR
"""

# NumPyNumPy, short for Numerical Python, is a fundamental open-source library in Python for scientific computing. Its core feature is the ndarray (n-dimensional array) object, which provides efficient storage and manipulation of large, multi-dimensional arrays and matrices.

# Key aspects of NumPy include:
# Efficient Array Operations:

# NumPy arrays are significantly faster and more memory-efficient than standard Python lists, especially for numerical operations on large datasets. This speed is attributed to its underlying implementation in C and optimized algorithms.
# Mathematical Functions:

# It offers a comprehensive collection of high-level mathematical functions for operating on these arrays, including linear algebra, Fourier transforms, random number generation, and basic statistical operations.
# Broadcasting:

# NumPy features broadcasting, which allows operations between arrays of different shapes without explicit looping, simplifying complex calculations.
# Foundation for Data Science:

# NumPy forms the basis for many other popular libraries in the Python data science ecosystem, such as SciPy, Pandas, and Matplotlib.

import numpy as np

# Create a 1-dimensional array
arr1 = np.array([1, 2, 3, 4, 5])
print(arr1)

# Create a 2-dimensional array (matrix)
arr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2)

import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr)

print(arr.ndim)
print(arr.shape)
print(arr.dtype)

# NumPy provides several built-in functions for creating arrays from scratch, enabling efficient numerical operations without requiring explicit loops. These functions are particularly useful for generating arrays with specific initial values or patterns.

# Common Built-in Array Creation Methods:
# 1.np.zeros(shape, dtype=float): Creates an array of the specified shape filled with zeros. The dtype argument allows specifying the data type of the array elements (e.g., int, float).
import numpy as np
arr_zeros = np.zeros((2,3))
print(arr_zeros)

#2.np.ones(shape, dtype=float): Creates an array of the specified shape filled with ones. Similar to np.zeros, the dtype can be specified.
import numpy as np
arr_one = np.ones((3,4))
print((arr_one))

# 3.np.full(shape, fill_value, dtype=None): Creates an array of the specified shape filled with a given fill_value.
import numpy as np
arr_full = np.full((2,3),7)
print(arr_full)

# 4.np.arange(start, stop, step, dtype=None): Creates an array with evenly spaced values within a given interval, similar to Python's built-in range() function but returning a NumPy array. The stop value is exclusive.
import numpy as np
arr_arange = np.arange(0,15,2)
print(arr_arange)

# 5.np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None): Creates an array with a specified number of evenly spaced values over a specified interval. num defines the number of samples to generate, and endpoint determines whether the stop value is included.
arr = np.linspace(0,1,5) # start=0, end=1, total 5 values
print(arr)

# 6.np.empty(shape, dtype=float): Creates an array of the specified shape and dtype without initializing its values. The content will be whatever happens to be in memory at the time of creation, making it faster for large arrays when the values will be overwritten later.
arr_empty = np.empty((2,2))
print(arr_empty) # Output: (values will be uninitialized and may vary)

import numpy as np
a = np.eye(3) #identity matrix : diagonal 1 , other 0
print(a)

# np.random.rand() â€“ Random numbers between 0 to 1
b = np.random.rand(2,3)
print(b)